<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TailorTalk - Enhanced Writing Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .dashboard {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        .sidebar.collapsed {
            transform: translateX(-100%);
        }

        .logo {
            font-size: 28px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 30px;
            text-align: center;
        }

        .new-project-btn {
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 30px;
            transition: transform 0.2s ease;
        }

        .new-project-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .menu-section {
            margin-bottom: 25px;
        }

        .menu-title {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .menu-item {
            padding: 12px 15px;
            cursor: pointer;
            border-radius: 6px;
            margin-bottom: 5px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
        }

        .menu-item:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateX(5px);
        }

        .menu-item.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .menu-icon {
            width: 20px;
            margin-right: 10px;
            font-size: 16px;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .hamburger {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .content-section {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            animation: fadeIn 0.5s ease;
        }

        .content-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .section-title {
            font-size: 28px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            margin-right: 15px;
            border-radius: 2px;
        }

        /* Enhanced Character Profile Card */
        .enhanced-character-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
            transition: transform 0.3s ease;
            position: relative;
        }

        .enhanced-character-card:hover {
            transform: translateY(-5px);
        }

        .character-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .character-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 32px;
            font-weight: bold;
            margin-right: 20px;
        }

        .character-info h3 {
            font-size: 24px;
            color: #333;
            margin-bottom: 5px;
        }

        .character-role-badge {
            background: #f0f2ff;
            color: #667eea;
            padding: 6px 15px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
        }

        .character-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .detail-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
        }

        .detail-title {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 8px;
        }

        .detail-content {
            color: #666;
            line-height: 1.5;
        }

        .strengths-weaknesses {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 15px 0;
        }

        .strength, .weakness {
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .strength {
            background: #d4edda;
            color: #155724;
        }

        .weakness {
            background: #f8d7da;
            color: #721c24;
        }

        .aesthetic-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .aesthetic-tag {
            background: #e3f2fd;
            color: #1565c0;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 11px;
        }

        .behavior-patterns {
            margin: 15px 0;
        }

        .behavior-item {
            background: #fff3cd;
            color: #856404;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 12px;
            margin: 5px 0;
            display: inline-block;
        }

        .character-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* Dialogue Ideation */
        .dialogue-suggestions {
            margin: 20px 0;
        }

        .dialogue-suggestion {
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .dialogue-suggestion:hover {
            border-color: #667eea;
            transform: translateX(5px);
        }

        .dialogue-suggestion.selected {
            border-color: #667eea;
            background: #f0f2ff;
        }

        .dialogue-checkbox {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 20px;
            height: 20px;
            border: 2px solid #667eea;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dialogue-checkbox.checked {
            background: #667eea;
        }

        .dialogue-checkbox.checked::after {
            content: '✓';
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        /* Plot Graph */
        .plot-graph-container {
            position: relative;
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .plot-canvas {
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            cursor: crosshair;
        }

        .plot-controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .zoom-controls {
            display: flex;
            gap: 5px;
        }

        .zoom-btn {
            width: 35px;
            height: 35px;
            border: none;
            background: #667eea;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }

        .zoom-btn:hover {
            background: #5a6fd8;
        }

        /* Annotation Modal */
        .annotation-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .annotation-content {
            background: white;
            padding: 25px;
            border-radius: 15px;
            width: 90%;
            max-width: 400px;
        }

        /* Stats Charts */
        .stats-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        /* Forms and Inputs */
        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .form-input, .form-textarea, .form-select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s ease;
            font-family: inherit;
        }

        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s ease;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #667eea;
            color: #667eea;
        }

        .btn-outline:hover {
            background: #667eea;
            color: white;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 12px;
        }

        /* Messages */
        .message {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: 600;
            display: none;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .hamburger {
                display: block;
            }

            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                z-index: 999;
            }

            .main-content {
                margin-left: 0;
                padding-top: 80px;
            }

            .form-grid, .character-details, .stats-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <!-- Hamburger Menu -->
        <button class="hamburger" onclick="toggleSidebar()">☰</button>

        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="logo">TailorTalk</div>
            
            <button class="new-project-btn" onclick="openNewProjectModal()">
                📝 New Project
            </button>

            <div class="menu-section">
                <div class="menu-title">Enhanced Features</div>
                <div class="menu-item active" onclick="showSection('characters', this)">
                    <span class="menu-icon">👥</span>
                    Character Research
                </div>
                <div class="menu-item" onclick="showSection('dialogue', this)">
                    <span class="menu-icon">💬</span>
                    Dialogue Ideation
                </div>
                <div class="menu-item" onclick="showSection('plot', this)">
                    <span class="menu-icon">📊</span>
                    Malleable Plot Line
                </div>
                <div class="menu-item" onclick="showSection('stats', this)">
                    <span class="menu-icon">📈</span>
                    Enhanced Stats
                </div>
            </div>

            <div class="menu-section">
                <div class="menu-title">Settings</div>
                <div class="menu-item" onclick="showSection('settings', this)">
                    <span class="menu-icon">⚙️</span>
                    Preferences
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Enhanced Character Research -->
            <div class="content-section active" id="characters">
                <h1 class="section-title">Enhanced Character Research</h1>
                <div class="message success" id="charactersMessage"></div>
                
                <!-- Enhanced Character Profiles Display -->
                <div id="enhancedCharacterGrid">
                    <!-- Enhanced character cards will be populated here -->
                </div>
                
                <!-- Character Creation Form -->
                <h3 style="margin: 30px 0 15px 0;">Create New Character Profile</h3>
                <div class="form-grid">
                    <div>
                        <div class="form-group">
                            <label class="form-label">Character Name</label>
                            <input type="text" class="form-input" id="enhancedCharacterName" placeholder="Enter character name...">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Role</label>
                            <select class="form-select" id="enhancedCharacterRole">
                                <option value="Protagonist">Protagonist</option>
                                <option value="Antagonist">Antagonist</option>
                                <option value="Supporting">Supporting</option>
                                <option value="Ally">Ally</option>
                                <option value="Mentor">Mentor</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Physical Traits</label>
                            <textarea class="form-textarea" id="physicalTraits" placeholder="Describe appearance, height, build, distinctive features..."></textarea>
                        </div>
                    </div>
                    
                    <div>
                        <div class="form-group">
                            <label class="form-label">Internal Traits</label>
                            <textarea class="form-textarea" id="internalTraits" placeholder="Personality, fears, motivations, goals..."></textarea>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Linked Dialogue (Optional)</label>
                            <select class="form-select" id="linkedDialogue">
                                <option value="">Select existing dialogue...</option>
                                <!-- Will be populated dynamically -->
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Aesthetic Themes</label>
                            <input type="text" class="form-input" id="aestheticThemes" placeholder="e.g. dark academia, cyberpunk, cottagecore...">
                        </div>
                    </div>
                </div>
                
                <button class="btn" onclick="generateCharacterProfile()">Generate Enhanced Profile</button>
            </div>

            <!-- Enhanced Dialogue Ideation -->
            <div class="content-section" id="dialogue">
                <h1 class="section-title">Enhanced Dialogue Ideation</h1>
                <div class="message success" id="dialogueMessage"></div>
                
                <!-- Dialogue Configuration -->
                <div class="form-grid">
                    <div>
                        <div class="form-group">
                            <label class="form-label">Select Character</label>
                            <select class="form-select" id="dialogueCharacterSelect">
                                <option value="">Choose character...</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Time Period/Setting</label>
                            <input type="text" class="form-input" id="timePeriod" placeholder="Medieval, Modern, Futuristic, etc.">
                        </div>
                    </div>
                    
                    <div>
                        <div class="form-group">
                            <label class="form-label">Current Plot Points</label>
                            <textarea class="form-textarea" id="plotContext" placeholder="What's happening in the story right now?"></textarea>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Extra Dialogue Line (Optional)</label>
                            <input type="text" class="form-input" id="extraDialogue" placeholder="Previous line or context...">
                        </div>
                    </div>
                </div>
                
                <button class="btn" onclick="generateDialogueSuggestions()">Generate Dialogue Ideas</button>
                <button class="btn btn-outline" onclick="regenerateDialogueSuggestions()">Regenerate Ideas</button>
                
                <!-- Dialogue Suggestions -->
                <div class="dialogue-suggestions" id="dialogueSuggestions">
                    <!-- Suggestions will be populated here -->
                </div>
                
                <button class="btn" onclick="saveSelectedDialogue()" style="display: none;" id="saveDialogueBtn">Save Selected Dialogue</button>
            </div>

            <!-- Malleable Plot Line -->
            <div class="content-section" id="plot">
                <h1 class="section-title">Malleable Plot Line</h1>
                <div class="message success" id="plotMessage"></div>
                
                <p style="margin-bottom: 20px; color: #666;">
                    Interactive plot visualization. Click to add points, drag to move them, and double-click on points for annotations.
                </p>
                
                <div class="plot-graph-container">
                    <canvas id="plotCanvas" class="plot-canvas" width="800" height="400"></canvas>
                    
                    <div class="plot-controls">
                        <div class="zoom-controls">
                            <button class="zoom-btn" onclick="zoomIn()">+</button>
                            <button class="zoom-btn" onclick="zoomOut()">-</button>
                            <button class="zoom-btn" onclick="resetZoom()">⌂</button>
                        </div>
                        <span style="margin-left: 15px; color: #666;">
                            Click to add points • Drag to move • Double-click points for annotations
                        </span>
                    </div>
                </div>
            </div>

            <!-- Enhanced Stats -->
            <div class="content-section" id="stats">
                <h1 class="section-title">Enhanced Writing Analytics</h1>
                
                <div class="stats-container">
                    <div class="chart-container">
                        <h3 class="chart-title">Writing Time (Hours)</h3>
                        <canvas id="timeChart" width="300" height="200"></canvas>
                    </div>
                    
                    <div class="chart-container">
                        <h3 class="chart-title">Character Focus Distribution</h3>
                        <canvas id="focusChart" width="300" height="200"></canvas>
                    </div>
                </div>
                
                <div class="chart-container" style="margin-top: 20px;">
                    <h3 class="chart-title">Project Progress</h3>
                    <div style="background: #f8f9fa; border-radius: 10px; padding: 4px; margin: 20px 0;">
                        <div id="progressBar" style="width: 65%; height: 30px; background: linear-gradient(45deg, #667eea, #764ba2); border-radius: 8px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                            65% Complete
                        </div>
                    </div>
                    <p style="text-align: center; color: #666;">45,892 words of estimated 70,000 word target</p>
                </div>
                
                <!-- Simulate Writing Activity -->
                <button class="btn" onclick="simulateWriting()">Simulate Writing Session</button>
                <button class="btn btn-outline" onclick="addCharacterFocus()">Add Character Focus</button>
            </div>

            <!-- Settings -->
            <div class="content-section" id="settings">
                <h1 class="section-title">Settings</h1>
                <div class="message success" id="settingsMessage"></div>
                
                <div class="form-group">
                    <label class="form-label">Daily Writing Goal (words)</label>
                    <input type="number" class="form-input" id="dailyGoal" value="1000" placeholder="1000">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Preferred Writing Time</label>
                    <select class="form-select" id="writingTime">
                        <option>Morning (6 AM - 12 PM)</option>
                        <option selected>Afternoon (12 PM - 6 PM)</option>
                        <option>Evening (6 PM - 12 AM)</option>
                        <option>Late Night (12 AM - 6 AM)</option>
                    </select>
                </div>
                
                <button class="btn" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Annotation Modal -->
    <div class="annotation-modal" id="annotationModal">
        <div class="annotation-content">
            <h3 style="margin-bottom: 15px;">Plot Point Annotation</h3>
            <div class="form-group">
                <label class="form-label">Title</label>
                <input type="text" class="form-input" id="annotationTitle" placeholder="Chapter/Scene title...">
            </div>
            <div class="form-group">
                <label class="form-label">Description</label>
                <textarea class="form-textarea" id="annotationDescription" placeholder="What happens at this point?"></textarea>
            </div>
            <button class="btn" onclick="saveAnnotation()">Save</button>
            <button class="btn btn-secondary" onclick="closeAnnotationModal()">Cancel</button>
        </div>
    </div>

    <script>
        // Global app state
        let appState = {
            characters: [
                {
                    id: 1,
                    name: "Elena Shadowheart",
                    role: "Protagonist",
                    physicalTraits: "Tall and lean, with striking silver hair and violet eyes. Has intricate tattoos on her arms that glow when using magic.",
                    internalTraits: "Brave but impulsive. Fears being abandoned again. Driven by a need to protect others, sometimes at her own expense.",
                    aestheticThemes: "dark academia, gothic fantasy, midnight blue",
                    strengths: ["Powerful magic", "Quick learner", "Loyal"],
                    weaknesses: ["Reckless", "Trust issues", "Impulsive"],
                    behaviors: ["Tends to act before thinking", "Does not tend to ask for help", "Tends to protect others first"]
                },
                {
                    id: 2,
                    name: "Marcus Steel",
                    role: "Ally",
                    physicalTraits: "Strong build with scars from battles, dark hair and piercing green eyes.",
                    internalTraits: "Loyal but cynical. Has trust issues from past betrayals.",
                    aestheticThemes: "military, steel gray, weathered",
                    strengths: ["Combat expert", "Strategic", "Loyal"],
                    weaknesses: ["Cynical", "Stubborn", "Distrustful"],
                    behaviors: ["Questions authority", "Protects allies", "Plans carefully"]
                }
            ],
            dialogue: [
                { id: 1, character: "Elena Shadowheart", text: "The shadows whisper secrets I'm not sure I want to hear.", context: "Discovering her powers", timePeriod: "Fantasy", extraContext: "" },
                { id: 2, character: "Marcus Steel", text: "Trust isn't given freely in my world. It's earned through blood and sacrifice.", context: "Meeting new allies", timePeriod: "Fantasy", extraContext: "" }
            ],
            plotPoints: [
                { x: 100, y: 300, id: 1, title: "Opening", description: "Story begins", hasAnnotation: true },
                { x: 250, y: 200, id: 2, title: "Inciting Incident", description: "Main conflict starts", hasAnnotation: true },
                { x: 400, y: 150, id: 3, title: "Rising Action", description: "Tension builds", hasAnnotation: true },
                { x: 550, y: 100, id: 4, title: "Climax", description: "Peak moment", hasAnnotation: true },
                { x: 700, y: 250, id: 5, title: "Resolution", description: "Story concludes", hasAnnotation: true }
            ],
            writingStats: {
                dailyHours: [2, 1.5, 3, 2.5, 1, 4, 2.8],
                characterFocus: { "Elena": 45, "Marcus": 25, "Lord Vex": 20, "Others": 10 },
                totalWords: 45892,
                targetWords: 70000
            },
            plotCanvas: null,
            currentEditPoint: null,
            zoomLevel: 1,
            panOffset: { x: 0, y: 0 },
            isDragging: false,
            dragPoint: null,
            selectedDialogue: [],
            currentDialogueSuggestions: []
        };

        // Initialize the application
        function initApp() {
            renderEnhancedCharacters();
            populateDialogueCharacters();
            initPlotCanvas();
            renderStats();
            updateLinkedDialogueOptions();
        }

        // Navigation
        function showSection(sectionId, menuElement) {
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(sectionId).classList.add('active');
            
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
            });
            if (menuElement) {
                menuElement.classList.add('active');
            }
            
            hideAllMessages();
        }

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('collapsed');
        }

        function openNewProjectModal() {
            showMessage('charactersMessage', 'New project feature coming soon!', 'success');
        }

        // Message functions
        function showMessage(messageId, text, type = 'success') {
            const messageElement = document.getElementById(messageId);
            messageElement.textContent = text;
            messageElement.className = `message ${type}`;
            messageElement.style.display = 'block';
            
            setTimeout(() => {
                messageElement.style.display = 'none';
            }, 3000);
        }

        function hideAllMessages() {
            document.querySelectorAll('.message').forEach(msg => {
                msg.style.display = 'none';
            });
        }

        // FEATURE 1: Enhanced Character Research
        function generateCharacterProfile() {
            const name = document.getElementById('enhancedCharacterName').value;
            const role = document.getElementById('enhancedCharacterRole').value;
            const physicalTraits = document.getElementById('physicalTraits').value;
            const internalTraits = document.getElementById('internalTraits').value;
            const aestheticThemes = document.getElementById('aestheticThemes').value;
            const linkedDialogue = document.getElementById('linkedDialogue').value;
            
            if (!name.trim()) {
                showMessage('charactersMessage', 'Please enter a character name', 'error');
                return;
            }
            
            // Generate strengths and weaknesses based on internal traits
            const strengths = generateTraits(internalTraits, 'positive');
            const weaknesses = generateTraits(internalTraits, 'negative');
            const behaviors = generateBehaviors(internalTraits);
            
            const newCharacter = {
                id: Date.now(),
                name,
                role,
                physicalTraits: physicalTraits || generatePhysicalDescription(name),
                internalTraits: internalTraits || generateInternalTraits(name),
                aestheticThemes: aestheticThemes || generateAestheticThemes(role),
                linkedDialogue,
                strengths,
                weaknesses,
                behaviors
            };
            
            appState.characters.push(newCharacter);
            renderEnhancedCharacters();
            populateDialogueCharacters();
            updateLinkedDialogueOptions();
            clearCharacterForm();
            showMessage('charactersMessage', `Character profile for ${name} generated successfully!`);
        }

        function generateTraits(internalTraits, type) {
            const positiveTraits = ['Brave', 'Loyal', 'Intelligent', 'Compassionate', 'Determined', 'Charismatic', 'Resourceful', 'Wise'];
            const negativeTraits = ['Impulsive', 'Stubborn', 'Paranoid', 'Reckless', 'Prideful', 'Secretive', 'Impatient', 'Cynical'];
            
            const traits = type === 'positive' ? positiveTraits : negativeTraits;
            const keywords = internalTraits.toLowerCase();
            
            // Smart trait generation based on keywords
            let selectedTraits = [];
            if (keywords.includes('brave') || keywords.includes('courage')) selectedTraits.push('Brave');
            if (keywords.includes('loyal') || keywords.includes('faithful')) selectedTraits.push('Loyal');
            if (keywords.includes('smart') || keywords.includes('intelligent')) selectedTraits.push('Intelligent');
            if (keywords.includes('impulsive') || keywords.includes('rash')) selectedTraits.push('Impulsive');
            if (keywords.includes('stubborn') || keywords.includes('headstrong')) selectedTraits.push('Stubborn');
            
            // Fill remaining slots randomly
            while (selectedTraits.length < 3) {
                const randomTrait = traits[Math.floor(Math.random() * traits.length)];
                if (!selectedTraits.includes(randomTrait)) {
                    selectedTraits.push(randomTrait);
                }
            }
            
            return selectedTraits.slice(0, 3);
        }

        function generateBehaviors(internalTraits) {
            const behaviorPatterns = [
                'Tends to act before thinking',
                'Does not tend to ask for help',
                'Tends to protect others first',
                'Often questions authority',
                'Prefers to work alone',
                'Always seeks the truth',
                'Avoids confrontation when possible',
                'Takes calculated risks'
            ];
            
            const keywords = internalTraits.toLowerCase();
            let behaviors = [];
            
            // Generate behaviors based on traits
            if (keywords.includes('impulsive') || keywords.includes('rash')) {
                behaviors.push('Tends to act before thinking');
            }
            if (keywords.includes('independent') || keywords.includes('loner')) {
                behaviors.push('Does not tend to ask for help');
            }
            if (keywords.includes('protective') || keywords.includes('caring')) {
                behaviors.push('Tends to protect others first');
            }
            
            // Fill remaining slots
            while (behaviors.length < 3) {
                const randomBehavior = behaviorPatterns[Math.floor(Math.random() * behaviorPatterns.length)];
                if (!behaviors.includes(randomBehavior)) {
                    behaviors.push(randomBehavior);
                }
            }
            
            return behaviors.slice(0, 3);
        }

        function generatePhysicalDescription(name) {
            const descriptions = [
                "Athletic build with piercing eyes and distinctive scars",
                "Tall and elegant with flowing hair and graceful movements", 
                "Compact frame with quick reflexes and alert expression",
                "Imposing presence with broad shoulders and steady gaze"
            ];
            return descriptions[Math.floor(Math.random() * descriptions.length)];
        }

        function generateInternalTraits(name) {
            const traits = [
                "Driven by a strong sense of justice but struggles with self-doubt",
                "Naturally curious but tends to be cautious in new situations",
                "Fiercely loyal to friends but has trust issues with strangers",
                "Ambitious and goal-oriented but sometimes neglects personal relationships"
            ];
            return traits[Math.floor(Math.random() * traits.length)];
        }

        function generateAestheticThemes(role) {
            const themes = {
                'Protagonist': 'heroic, warm colors, dawn light',
                'Antagonist': 'dark academia, shadows, deep reds',
                'Supporting': 'earthy tones, cozy cottage, autumn',
                'Ally': 'bright blues, starlight, ocean waves',
                'Mentor': 'ancient wisdom, candlelight, old books'
            };
            return themes[role] || 'mysterious, twilight, silver';
        }

        function renderEnhancedCharacters() {
            const grid = document.getElementById('enhancedCharacterGrid');
            grid.innerHTML = '';
            
            appState.characters.forEach(character => {
                const card = document.createElement('div');
                card.className = 'enhanced-character-card';
                card.innerHTML = `
                    <div class="character-header">
                        <div class="character-avatar">${character.name.charAt(0).toUpperCase()}</div>
                        <div class="character-info">
                            <h3>${character.name}</h3>
                            <div class="character-role-badge">${character.role}</div>
                        </div>
                    </div>
                    
                    <div class="character-details">
                        <div class="detail-section">
                            <div class="detail-title">Physical Traits</div>
                            <div class="detail-content">${character.physicalTraits}</div>
                        </div>
                        
                        <div class="detail-section">
                            <div class="detail-title">Internal Traits</div>
                            <div class="detail-content">${character.internalTraits}</div>
                        </div>
                    </div>
                    
                    <div class="strengths-weaknesses">
                        ${character.strengths.map(s => `<span class="strength">${s}</span>`).join('')}
                        ${character.weaknesses.map(w => `<span class="weakness">${w}</span>`).join('')}
                    </div>
                    
                    <div class="behavior-patterns">
                        <div class="detail-title">Behavior Patterns</div>
                        ${character.behaviors.map(b => `<div class="behavior-item">${b}</div>`).join('')}
                    </div>
                    
                    <div class="aesthetic-tags">
                        ${character.aestheticThemes.split(',').map(theme => 
                            `<span class="aesthetic-tag">${theme.trim()}</span>`
                        ).join('')}
                    </div>
                    
                    <div class="character-actions">
                        <button class="btn btn-small" onclick="saveCharacterProfile(${character.id})">Save Profile</button>
                        <button class="btn btn-outline btn-small" onclick="editCharacterProfile(${character.id})">Edit Profile</button>
                        <button class="btn btn-secondary btn-small" onclick="deleteCharacter(${character.id})">Delete</button>
                    </div>
                `;
                grid.appendChild(card);
            });
        }

        function saveCharacterProfile(characterId) {
            showMessage('charactersMessage', 'Character profile saved successfully!');
        }

        function editCharacterProfile(characterId) {
            const character = appState.characters.find(c => c.id === characterId);
            if (!character) return;
            
            // Populate form with existing data
            document.getElementById('enhancedCharacterName').value = character.name;
            document.getElementById('enhancedCharacterRole').value = character.role;
            document.getElementById('physicalTraits').value = character.physicalTraits;
            document.getElementById('internalTraits').value = character.internalTraits;
            document.getElementById('aestheticThemes').value = character.aestheticThemes;
            document.getElementById('linkedDialogue').value = character.linkedDialogue || '';
            
            // Remove character from array (will be re-added when form is submitted)
            appState.characters = appState.characters.filter(c => c.id !== characterId);
            renderEnhancedCharacters();
            populateDialogueCharacters();
            updateLinkedDialogueOptions();
            
            showMessage('charactersMessage', 'Character loaded for editing. Make changes and click Generate to update.');
        }

        function deleteCharacter(characterId) {
            if (confirm('Are you sure you want to delete this character?')) {
                appState.characters = appState.characters.filter(c => c.id !== characterId);
                renderEnhancedCharacters();
                populateDialogueCharacters();
                updateLinkedDialogueOptions();
                showMessage('charactersMessage', 'Character deleted successfully.');
            }
        }

        function clearCharacterForm() {
            document.getElementById('enhancedCharacterName').value = '';
            document.getElementById('physicalTraits').value = '';
            document.getElementById('internalTraits').value = '';
            document.getElementById('aestheticThemes').value = '';
            document.getElementById('linkedDialogue').value = '';
            document.getElementById('enhancedCharacterRole').value = 'Protagonist';
        }

        // FEATURE 2: Enhanced Dialogue Ideation
        function generateDialogueSuggestions() {
            const characterName = document.getElementById('dialogueCharacterSelect').value;
            const timePeriod = document.getElementById('timePeriod').value;
            const plotContext = document.getElementById('plotContext').value;
            const extraDialogue = document.getElementById('extraDialogue').value;
            
            if (!characterName) {
                showMessage('dialogueMessage', 'Please select a character first', 'error');
                return;
            }
            
            const character = appState.characters.find(c => c.name === characterName);
            const suggestions = generateDialogueOptions(character, timePeriod, plotContext, extraDialogue);
            
            renderDialogueSuggestions(suggestions);
            showMessage('dialogueMessage', `Generated ${suggestions.length} dialogue suggestions for ${characterName}`);
        }

        function generateDialogueOptions(character, timePeriod, plotContext, extraDialogue) {
            const baseDialogues = [
                "I never thought it would come to this.",
                "There's something you need to know about what happened.",
                "We don't have much time left.",
                "This changes everything.",
                "I should have told you sooner.",
                "What choice do we really have?",
                "The truth is more complicated than you think.",
                "I've been waiting for this moment."
            ];
            
            const contextualDialogues = [];
            
            // Generate based on character traits
            if (character) {
                if (character.strengths.includes('Brave')) {
                    contextualDialogues.push("I won't back down, not when so much is at stake.");
                }
                if (character.weaknesses.includes('Impulsive')) {
                    contextualDialogues.push("Forget the plan - we're doing this now!");
                }
                if (character.behaviors.includes('Tends to protect others first')) {
                    contextualDialogues.push("Get behind me. I won't let anything happen to you.");
                }
                if (character.weaknesses.includes('Cynical')) {
                    contextualDialogues.push("Of course it comes to this. It always does.");
                }
                if (character.strengths.includes('Loyal')) {
                    contextualDialogues.push("I'll stand by you, no matter what happens.");
                }
                if (character.weaknesses.includes('Stubborn')) {
                    contextualDialogues.push("My mind is made up. There's no changing it now.");
                }
            }
            
            // Add context-based dialogues
            if (plotContext.toLowerCase().includes('danger')) {
                contextualDialogues.push("The danger is closer than we realized.");
            }
            if (plotContext.toLowerCase().includes('secret')) {
                contextualDialogues.push("Some secrets are worth keeping, others will destroy us.");
            }
            if (plotContext.toLowerCase().includes('betrayal')) {
                contextualDialogues.push("How could you? After everything we've been through.");
            }
            if (plotContext.toLowerCase().includes('love')) {
                contextualDialogues.push("My feelings for you complicate everything.");
            }
            
            // Add time period flavor
            if (timePeriod.toLowerCase().includes('medieval')) {
                contextualDialogues.push("By the king's decree, this cannot stand.");
                contextualDialogues.push("Honor demands we act, though death may follow.");
            } else if (timePeriod.toLowerCase().includes('modern')) {
                contextualDialogues.push("We need to call the police. Now.");
                contextualDialogues.push("This is way above our pay grade.");
            } else if (timePeriod.toLowerCase().includes('future')) {
                contextualDialogues.push("The neural interface is showing anomalies.");
                contextualDialogues.push("Our coordinates in space-time are shifting.");
            }
            
            // Combine and randomize
            const allDialogues = [...baseDialogues, ...contextualDialogues];
            const shuffled = allDialogues.sort(() => 0.5 - Math.random());
            
            return shuffled.slice(0, 5).map((text, index) => ({
                id: Date.now() + index + Math.random(),
                character: character?.name || 'Unknown',
                text,
                context: plotContext || 'General conversation',
                timePeriod: timePeriod || 'General',
                extraContext: extraDialogue
            }));
        }

        function renderDialogueSuggestions(suggestions) {
            const container = document.getElementById('dialogueSuggestions');
            container.innerHTML = '';
            
            if (suggestions.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No dialogue suggestions available. Please check your inputs and try again.</p>';
                return;
            }
            
            suggestions.forEach((suggestion, index) => {
                const div = document.createElement('div');
                div.className = 'dialogue-suggestion';
                div.setAttribute('data-suggestion-id', suggestion.id);
                div.innerHTML = `
                    <div class="dialogue-checkbox" onclick="toggleDialogueSelection(${suggestion.id}, event)"></div>
                    <h4 style="color: #667eea; margin-bottom: 8px;">${suggestion.character}</h4>
                    <p style="font-style: italic; margin-bottom: 10px; font-size: 16px; line-height: 1.4;">"${suggestion.text}"</p>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px;">
                        ${suggestion.timePeriod ? `<small style="background: #e3f2fd; color: #1565c0; padding: 3px 8px; border-radius: 12px;">📅 ${suggestion.timePeriod}</small>` : ''}
                        ${suggestion.context ? `<small style="background: #f3e5f5; color: #7b1fa2; padding: 3px 8px; border-radius: 12px;">📝 ${suggestion.context.substring(0, 30)}...</small>` : ''}
                    </div>
                `;
                
                div.onclick = (e) => {
                    if (!e.target.classList.contains('dialogue-checkbox') && !e.target.parentElement.classList.contains('dialogue-checkbox')) {
                        toggleDialogueSelection(suggestion.id, e);
                    }
                };
                
                container.appendChild(div);
            });
            
            appState.currentDialogueSuggestions = suggestions;
            appState.selectedDialogue = [];
            updateSaveDialogueButton();
        }

        function toggleDialogueSelection(suggestionId, event) {
            event.stopPropagation();
            
            const suggestionElement = document.querySelector(`[data-suggestion-id="${suggestionId}"]`);
            const checkbox = suggestionElement.querySelector('.dialogue-checkbox');
            
            if (appState.selectedDialogue.includes(suggestionId)) {
                appState.selectedDialogue = appState.selectedDialogue.filter(id => id !== suggestionId);
                suggestionElement.classList.remove('selected');
                checkbox.classList.remove('checked');
            } else {
                appState.selectedDialogue.push(suggestionId);
                suggestionElement.classList.add('selected');
                checkbox.classList.add('checked');
            }
            
            updateSaveDialogueButton();
        }

        function updateSaveDialogueButton() {
            const saveBtn = document.getElementById('saveDialogueBtn');
            if (appState.selectedDialogue && appState.selectedDialogue.length > 0) {
                saveBtn.style.display = 'inline-block';
                saveBtn.textContent = `Save Selected Dialogue (${appState.selectedDialogue.length})`;
            } else {
                saveBtn.style.display = 'none';
            }
        }

        function regenerateDialogueSuggestions() {
            const characterName = document.getElementById('dialogueCharacterSelect').value;
            if (!characterName) {
                showMessage('dialogueMessage', 'Please select a character first', 'error');
                return;
            }
            
            // Clear previous selections
            appState.selectedDialogue = [];
            updateSaveDialogueButton();
            
            // Generate new suggestions
            generateDialogueSuggestions();
            showMessage('dialogueMessage', 'Generated new dialogue suggestions!');
        }

        function saveSelectedDialogue() {
            const selectedSuggestions = appState.currentDialogueSuggestions.filter(s => 
                appState.selectedDialogue.includes(s.id)
            );
            
            if (selectedSuggestions.length === 0) {
                showMessage('dialogueMessage', 'No dialogue selected to save', 'error');
                return;
            }
            
            selectedSuggestions.forEach(suggestion => {
                appState.dialogue.push({
                    id: Date.now() + Math.random(),
                    character: suggestion.character,
                    text: suggestion.text,
                    context: suggestion.context,
                    timePeriod: suggestion.timePeriod,
                    extraContext: suggestion.extraContext
                });
            });
            
            updateLinkedDialogueOptions();
            
            // Clear selections
            appState.selectedDialogue = [];
            document.querySelectorAll('.dialogue-suggestion.selected').forEach(el => {
                el.classList.remove('selected');
                el.querySelector('.dialogue-checkbox').classList.remove('checked');
            });
            updateSaveDialogueButton();
            
            showMessage('dialogueMessage', `Saved ${selectedSuggestions.length} dialogue lines to your collection!`);
        }

        function populateDialogueCharacters() {
            const select = document.getElementById('dialogueCharacterSelect');
            select.innerHTML = '<option value="">Choose character...</option>';
            
            appState.characters.forEach(character => {
                const option = document.createElement('option');
                option.value = character.name;
                option.textContent = character.name;
                select.appendChild(option);
            });
        }

        function updateLinkedDialogueOptions() {
            const select = document.getElementById('linkedDialogue');
            select.innerHTML = '<option value="">Select existing dialogue...</option>';
            
            appState.dialogue.forEach(dialogue => {
                const option = document.createElement('option');
                option.value = dialogue.id;
                option.textContent = `${dialogue.character}: "${dialogue.text.substring(0, 40)}..."`;
                select.appendChild(option);
            });
        }

        // FEATURE 3: Malleable Plot Line
        function initPlotCanvas() {
            const canvas = document.getElementById('plotCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            appState.plotCanvas = { canvas, ctx };
            
            // Set up event listeners
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('dblclick', handleCanvasDoubleClick);
            
            drawPlotGraph();
        }

        function drawPlotGraph() {
            if (!appState.plotCanvas) return;
            
            const { canvas, ctx } = appState.plotCanvas;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply zoom and pan
            ctx.save();
            ctx.scale(appState.zoomLevel, appState.zoomLevel);
            ctx.translate(appState.panOffset.x, appState.panOffset.y);
            
            // Draw grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const gridWidth = canvas.width / appState.zoomLevel;
            const gridHeight = canvas.height / appState.zoomLevel;
            
            for (let x = 0; x <= gridWidth; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, gridHeight);
                ctx.stroke();
            }
            
            for (let y = 0; y <= gridHeight; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(gridWidth, y);
                ctx.stroke();
            }
            
            // Draw plot line connecting points
            if (appState.plotPoints.length > 1) {
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(appState.plotPoints[0].x, appState.plotPoints[0].y);
                
                for (let i = 1; i < appState.plotPoints.length; i++) {
                    ctx.lineTo(appState.plotPoints[i].x, appState.plotPoints[i].y);
                }
                ctx.stroke();
            }
            
            // Draw plot points
            appState.plotPoints.forEach(point => {
                // Draw point circle
                ctx.fillStyle = point.hasAnnotation ? '#764ba2' : '#667eea';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Add border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw point label
                ctx.fillStyle = '#333';
                ctx.font = '12px sans-serif';
                const labelX = point.x + 15;
                const labelY = point.y - 10;
                ctx.fillText(point.title, labelX, labelY);
                
                // Add annotation indicator
                if (point.hasAnnotation) {
                    ctx.fillStyle = '#ff6b6b';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.fillText('📝', point.x + 15, point.y + 20);
                }
            });
            
            ctx.restore();
        }

        function getCanvasCoordinates(e) {
            const rect = appState.plotCanvas.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / appState.zoomLevel - appState.panOffset.x;
            const y = (e.clientY - rect.top) / appState.zoomLevel - appState.panOffset.y;
            return { x, y };
        }

        function handleCanvasMouseDown(e) {
            const { x, y } = getCanvasCoordinates(e);
            
            // Check if clicking on existing point
            const clickedPoint = appState.plotPoints.find(point => {
                const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                return distance <= 12;
            });
            
            if (clickedPoint) {
                appState.isDragging = true;
                appState.dragPoint = clickedPoint;
                appState.plotCanvas.canvas.style.cursor = 'grabbing';
            } else {
                // Add new point if not clicking on existing point
                const newPoint = {
                    id: Date.now(),
                    x: Math.max(10, Math.min(x, appState.plotCanvas.canvas.width - 10)),
                    y: Math.max(10, Math.min(y, appState.plotCanvas.canvas.height - 10)),
                    title: `Point ${appState.plotPoints.length + 1}`,
                    description: 'New plot point',
                    hasAnnotation: false
                };
                
                appState.plotPoints.push(newPoint);
                drawPlotGraph();
                showMessage('plotMessage', 'New plot point added!');
            }
        }

        function handleCanvasMouseMove(e) {
            if (appState.isDragging && appState.dragPoint) {
                const { x, y } = getCanvasCoordinates(e);
                
                appState.dragPoint.x = Math.max(10, Math.min(x, appState.plotCanvas.canvas.width - 10));
                appState.dragPoint.y = Math.max(10, Math.min(y, appState.plotCanvas.canvas.height - 10));
                
                drawPlotGraph();
            } else {
                // Change cursor on hover
                const { x, y } = getCanvasCoordinates(e);
                const hoveredPoint = appState.plotPoints.find(point => {
                    const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                    return distance <= 12;
                });
                
                appState.plotCanvas.canvas.style.cursor = hoveredPoint ? 'grab' : 'crosshair';
            }
        }

        function handleCanvasMouseUp(e) {
            if (appState.isDragging) {
                showMessage('plotMessage', 'Plot point moved!');
            }
            
            appState.isDragging = false;
            appState.dragPoint = null;
            appState.plotCanvas.canvas.style.cursor = 'crosshair';
        }

        function handleCanvasDoubleClick(e) {
            const { x, y } = getCanvasCoordinates(e);
            
            // Find clicked point
            const clickedPoint = appState.plotPoints.find(point => {
                const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                return distance <= 12;
            });
            
            if (clickedPoint) {
                openAnnotationModal(clickedPoint);
            }
        }

        function openAnnotationModal(point) {
            appState.currentEditPoint = point;
            document.getElementById('annotationTitle').value = point.title;
            document.getElementById('annotationDescription').value = point.description || '';
            document.getElementById('annotationModal').style.display = 'flex';
        }

        function closeAnnotationModal() {
            document.getElementById('annotationModal').style.display = 'none';
            appState.currentEditPoint = null;
        }

        function saveAnnotation() {
            if (appState.currentEditPoint) {
                const title = document.getElementById('annotationTitle').value;
                const description = document.getElementById('annotationDescription').value;
                
                appState.currentEditPoint.title = title || `Point ${appState.plotPoints.indexOf(appState.currentEditPoint) + 1}`;
                appState.currentEditPoint.description = description;
                appState.currentEditPoint.hasAnnotation = description.trim().length > 0;
                
                drawPlotGraph();
                closeAnnotationModal();
                showMessage('plotMessage', 'Plot point annotation saved!');
            }
        }

        function zoomIn() {
            if (appState.zoomLevel < 5) {
                appState.zoomLevel *= 1.2;
                drawPlotGraph();
                showMessage('plotMessage', `Zoomed in to ${Math.round(appState.zoomLevel * 100)}%`);
            }
        }

        function zoomOut() {
            if (appState.zoomLevel > 0.1) {
                appState.zoomLevel /= 1.2;
                drawPlotGraph();
                showMessage('plotMessage', `Zoomed out to ${Math.round(appState.zoomLevel * 100)}%`);
            }
        }

        function resetZoom() {
            appState.zoomLevel = 1;
            appState.panOffset = { x: 0, y: 0 };
            drawPlotGraph();
            showMessage('plotMessage', 'View reset to 100%');
        }

        // FEATURE 4: Enhanced Stats
        function renderStats() {
            renderTimeChart();
            renderFocusChart();
            updateProgressBar();
        }

        function renderTimeChart() {
            const canvas = document.getElementById('timeChart');
            const ctx = canvas.getContext('2d');
            const data = appState.writingStats.dailyHours;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const maxHours = Math.max(...data, 1);
            const barWidth = canvas.width / data.length;
            const colors = ['#667eea', '#764ba2', '#5a6fd8', '#8e6dc7', '#7b68ee', '#9370db', '#8a2be2'];
            const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            
            data.forEach((hours, index) => {
                const barHeight = (hours / maxHours) * (canvas.height - 50);
                const x = index * barWidth;
                const y = canvas.height - barHeight - 30;
                
                // Bar gradient
                const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
                gradient.addColorStop(0, colors[index % colors.length]);
                gradient.addColorStop(1, '#e8eaf6');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + 5, y, barWidth - 10, barHeight);
                
                // Bar border
                ctx.strokeStyle = colors[index % colors.length];
                ctx.lineWidth = 2;
                ctx.strokeRect(x + 5, y, barWidth - 10, barHeight);
                
                // Labels
                ctx.fillStyle = '#333';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(days[index % days.length], x + barWidth/2, canvas.height - 15);
                
                // Hours label
                ctx.fillStyle = '#667eea';
                ctx.font = 'bold 9px sans-serif';
                ctx.fillText(hours + 'h', x + barWidth/2, y - 5);
            });
            
            // Chart title
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Last 7 Days', 10, 15);
        }

        function renderFocusChart() {
            const canvas = document.getElementById('focusChart');
            const ctx = canvas.getContext('2d');
            const data = appState.writingStats.characterFocus;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 30;
            
            const colors = ['#667eea', '#764ba2', '#5a6fd8', '#8e6dc7', '#7b68ee'];
            const total = Object.values(data).reduce((sum, val) => sum + val, 0);
            
            let currentAngle = -Math.PI / 2;
            Object.entries(data).forEach(([character, percentage], index) => {
                const sliceAngle = (percentage / total) * 2 * Math.PI;
                
                // Draw slice
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                ctx.lineTo(centerX, centerY);
                
                // Gradient for slice
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, colors[index % colors.length]);
                gradient.addColorStop(1, colors[index % colors.length] + '80');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Slice border
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Labels
                const labelAngle = currentAngle + sliceAngle / 2;
                const labelRadius = radius * 0.7;
                const labelX = centerX + Math.cos(labelAngle) * labelRadius;
                const labelY = centerY + Math.sin(labelAngle) * labelRadius;
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.strokeText(character, labelX, labelY);
                ctx.fillText(character, labelX, labelY);
                
                ctx.strokeText(`${percentage}%`, labelX, labelY + 14);
                ctx.fillText(`${percentage}%`, labelX, labelY + 14);
                
                currentAngle += sliceAngle;
            });
            
            // Center circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 20, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function updateProgressBar() {
            const progress = Math.min(100, Math.round((appState.writingStats.totalWords / appState.writingStats.targetWords) * 100));
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = progress + '%';
            progressBar.textContent = progress + '% Complete';
            
            // Update progress text
            const progressText = progressBar.parentElement.nextElementSibling;
            progressText.textContent = `${appState.writingStats.totalWords.toLocaleString()} words of estimated ${appState.writingStats.targetWords.toLocaleString()} word target`;
        }

        function simulateWriting() {
            // Simulate a writing session
            const randomHours = Math.random() * 3 + 0.5; // 0.5 to 3.5 hours
            const wordsWritten = Math.floor(Math.random() * 1500) + 500; // 500-2000 words
            
            appState.writingStats.dailyHours.push(Math.round(randomHours * 10) / 10);
            appState.writingStats.totalWords += wordsWritten;
            
            if (appState.writingStats.dailyHours.length > 7) {
                appState.writingStats.dailyHours.shift(); // Keep only last 7 days
            }
            
            renderStats();
            showMessage('statsMessage', `Writing session complete! Added ${Math.round(randomHours * 10) / 10} hours and ${wordsWritten} words.`);
        }

        function addCharacterFocus() {
            const characters = Object.keys(appState.writingStats.characterFocus);
            const randomCharacter = characters[Math.floor(Math.random() * characters.length)];
            const focusIncrease = Math.floor(Math.random() * 15) + 5;
            
            // Redistribute focus
            appState.writingStats.characterFocus[randomCharacter] += focusIncrease;
            
            // Normalize to 100%
            const total = Object.values(appState.writingStats.characterFocus).reduce((sum, val) => sum + val, 0);
            Object.keys(appState.writingStats.characterFocus).forEach(char => {
                appState.writingStats.characterFocus[char] = Math.round((appState.writingStats.characterFocus[char] / total) * 100);
            });
            
            renderFocusChart();
            showMessage('statsMessage', `Increased focus on ${randomCharacter} by ${focusIncrease} points!`);
        }

        function saveSettings() {
            const dailyGoal = document.getElementById('dailyGoal').value;
            const writingTime = document.getElementById('writingTime').value;
            
            // Update target words if daily goal changed
            if (dailyGoal && !isNaN(dailyGoal)) {
                appState.writingStats.targetWords = Math.round(dailyGoal * 70); // Rough estimate: 70 days to complete
                updateProgressBar();
            }
            
            showMessage('settingsMessage', 'Settings saved successfully! Daily goal and preferences updated.');
        }

        // Click outside modal to close
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('annotationModal');
            if (e.target === modal) {
                closeAnnotationModal();
            }
        });

        // Initialize app when page loads
        window.addEventListener('load', initApp);
    </script>
</body>
</html>